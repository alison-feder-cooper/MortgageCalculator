# Mortgage Calculator

## Running the App

Execute ```./gradlew build && java -jar build/libs/gs-spring-boot-0.1.0.jar``` from within the 
app directory.

Or, import the project into IntelliJ and as a Spring Boot project and click "Run" for 
`MortgageCalculatorApplication.java`. IntelliJ has great Spring Boot integration.

## Overview

I've used Spring Boot to implement this mortgage calculator. It consists of both an API (one controller for retrieving
today's best quotes), and a cron-like scheduled task for ingesting data from lenders and saving par value daily rates 
to a separate table, functioning like a cache (ish). (See `APIController.java` and `ScheduledTasks.java`, respectively.)

The API controller lazily generates quotes. It first checks if there are quotes for the specified loan amount
for that day, and if there are it returns them. Otherwise, it generates quotes from the par value rates for the day.
The endpoint will throw an exception if there aren't par values for that day. I'm not sure what it exactly what it should
look like in between days / quotes being provided through lenders, but for now it seemed safest to handle this case by 
explicitly acknowleding it/ throwing a specific exception that could be handled by the client. The controller, as well 
as all service methods, deal in cents. When it comes to money, this seems safest to do, instead of working with floating 
point numbers. Java does have BigDecimal for added precision, but in case we wanted to implement other service code or 
client code in languages that don't have something analogous, cents seems the safest in terms of communication/ an API. 
Again, the client code can handle formatting appropriately to present this value in dollars / with a dollar sign / 
however it chooses.

Since the controller does not persist any stateful information (and the repositories and services are transactional),
the concurrent request handling Spring Boot provides for free (i.e. with no additional configuration)
suffices.

### Some implementation decision details

There are further comments on this within the model calculator package, but I took some short cuts here because I wasn't 
sure exactly what to do with adjusted rate calculators without knowing from lenders how rates will adjust (I'd expect 
another field/an adjustment rate in the lender data files, based on the research I did). So, it might be a bit of a 
cop-out, but I had the adjusted rate calculator delegate to the fixed rate calculator for now (since there will be a 
fixed rate portion for the product), and in the response in the API included a description field, to explain an overall 
idea for the kind of  mortgage product (e.g. for a 5-1 adjustable mortgage, the description says that the monthly payment 
is fixed for 5 years, and the adjusts after, but does not say by how much).

For the parser, I wrote something quick and dirty that gets the job done. There is likely a cleaner way to do this with
existing Java utilities, e.g. Apache commons. However, I timeboxed testing this out, and converting from a `String` code 
to an enum (for `MortgageProductType`) was a bit gnarly given how I implemented the enum as a human-readable string with 
a property containing the code.

Other shortcuts include not using Spring DI in the quote service to wire up calculator. This was the one instance of 
parameter injection in this app, so instead of implementing a configuration I new-ed up calculators in the service
directly. 

Also, I'm not an expert in Spring Boot (I picked it for this assignment because Java is my strongest language, but for
most of my career I've written algorithms deep in server logic as opposed to standalone apps and APIs). One of the 
awesome things about it is the data access methods you get for free for simple queries using `CrudRepository`. I learned 
on the flip side (while writing a query for identifying par values) that writing more complex queries (that do not 
rely on those autogenerated for-free simpler queries) seems more complicated than it should be. The queries are expected 
to be in JPQL instead of SQL, and traditional subquery syntax doesn't seem to be implemented in JPQL. Apparently it's 
possible to write native SQL queries, but a few attempts at that yielded very wonky runtime behavior around not 
recognizing method parameters. I timeboxed that as well, and ended up implementing par value rate identification in Java 
just to get something working. 

For more information on some decisions I made/ shortcuts I took, please see inline comments in code.


## Tests

I've included unit tests that mock the mvc framework / make api calls and validate the response. 

I've also included some modelling unit tests, CRUD repository and service integration tests. 
